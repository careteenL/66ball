# JS知识

- todo：使用doctoc生成目录

## 原始类型有哪几种？null是对象吗？基本数据类型和引用类型在存储上的差别？

- 原始类型有`Undefined、Null、Boolean、number、string、symbol`六种，ES6新增了`symbol`类型。
- `null`是一个关键字并非对象，它的语义表示空值。
- 基本数据类型和引用类型在`存储`上的区别是：
  - 基本数据类型存储在`栈`中，因为这些基本类型占据的空间是固定的，所以将其存入较小的内存区域栈中，便于快速查询变量的值。比如`var a = 10; var b = a; b = 20; console.log(a)`，此时的打印结果是`10`，因为`var b = a`只是将`a`的值复制了一份，去更改`b`的值并不会影响`a`。
  - 引用数据类型存储在`堆`中，也就是说，在栈中存储在变量处的值是一个指向堆内存的一个引用地址。比如`var obj1 = new Object(); var obj2 = obj1; obj2.name = 'careteen'; console.log(obj1.name)`，此时的打印结果是`careteen`，因为`var obj2 = obj1`将`obj1`的引用地址复制了一份，当更改其中一个变量的值时，都是操作的同一块推内存空间，另一个也会更新。

## 说一下JS中类型转换的规则？

- 存在的意义：由于JavaScript是一门弱类型语言，类型转换是非常频繁的。
- 转换规则
  - 先上一张图
   ![tree-type_transform](../../assets/tree-type_transform.jpg)
  - 基本类型之间转换
    - 将`null`,`undefined`,`true/false`,`number`转换为`boolean,number,string`规则较为简单，如上图所示。
  - StringToNumber
    - `string`转换为`number`会稍微复杂一点。转为`number`类型提供了`parseInt/parseFloat`两个函数，也可以用`Number`基本对象类型进行转换。
    - `parseInt`函数提供两个参数，第二个参数是第一个参数的进制数，如果不传会存在一些兼容性问题，在不同浏览器表现不一致，所以在工作中使用到了此函数，都约定好了传第二个参数。
    - 还是强烈建议使用`Number`进行转换。避免可能存在的问题发生。
  - NumberToString
    - 不那么重要吧
  - 装箱转换
    - 也就是将基本类型转为对象类型。其实每一种基本类型在对象中都有对应的类（Number...）。
  - 拆箱转换
    - 也就是将对象类型转换为基本类型。其中存在一些隐式规则。会尝试调用对象的`valueOf`和`toString`方法进行转换。
      - 比如所求表达式的结果看起来像一个`Number`类型，那么会先调用`valueOf`再调用`toString`去尝试转换
      - 比如所求表达式的结果看起来像一个`String`类型，那么会先调用`toString`再调用`valueOf`去尝试转换

- 参考[winter重学前端](https://time.geekbang.org/column/article/78884?utm_term=zeusRWKG3&utm_source=app&utm_medium=zhuanti)

## == 和 === 区别，什么情况用 == ？

- 三个等号为严格判断，即前提是两个变量若为同一种类型才会进行值是否相等的判断，否则直接返回false。
- 两个等号则不严格，若两个变量类型不一致，则会尝试将其转为同一类型再进行值得判断。转换规则挺多，记不住，所以开发过程都不会使用两个等号，避免一些不必要的bug。
- 两个等号的应用场景：当不确定两个变量类型是否相同时，但仍需比较两个变量，则可以使用。

- `==`操作符的一些规则
![tree-==](../../assets/tree-==.png)
  解析`[] == ![] // => true`的转换过程：
  ```js
  // [] 转成 true，然后取反变成 false
  [] == false
  // 根据第 8 条得出
  [] == ToNumber(false)
  [] == 0
  // 根据第 10 条得出
  ToPrimitive([]) == 0
  // [].toString() -> ''
  '' == 0
  // 根据第 6 条得出
  0 == 0 // -> true
  ```

## 为什么 0.1+0.2 != 0.3 ？

- 因为计算机存储数字的方式是采用`IEEE-754`规定的双精度浮点数规则。此规则规定一个数用`64`位存储，第0位到第51位为尾数部分，第52位到第62位为指数部分，第63位为符号位。
- 十进制整数转为二级制是通过除二取余的方式，十进制小数转为二进制是通过乘二取整的方式。
- 十进制小数转为二进制过程一般会无限循环，此时因为存储尾数有限为丢掉一部分。`所以此过程可能会丢失精度`。
- 浮点数的运算是十进制小数转为二进制后进行`对阶运算`，此过程也可能丢失精度。
- 由以上两点可能失去精度，故`0.1+0.2!=0.3`
- 解决方法
  - 可以将其转为整数再进行计算。但是对于大数来说不太友好
  - `Number`提供一个最小精度`EPSILON`可实现判断
    ```js
    // 如果两个数的差值的绝对值小于这个精度，则认为这两个数相等。
    Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON
    ```
- 参考自[0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？](https://www.sohu.com/a/254865340_796914)

## 深拷贝和浅拷贝的区别？如何实现？

## new 的原理是什么？通过 new 的方式创建的对象和通过字面量创建有什么区别？

## 如何正确判断 this ？箭头函数的 this 是什么？

## 什么是闭包？

## 如何理解原型？如何理解原型链？

## 什么是变量提升？

- 作用域
  - 前置：编译
    - 词法分析
    - 语法分析
    - 生成代码
  - 前置：扮演的角色
    - 引擎
    - 编译器
    - 作用域
  - 词法作用域
    - 一些欺骗的词法（不推荐使用，可能造成性能问题）
      - eval
      - with
      - new Function 安全性较上面两种高一点
  - 函数作用域和块作用域
    - 块作用域
      - ES3提供的`try...catch`的`catch`分支
      - ES6提供的`let/const`关键字
      - with（但不推荐使用）

- 变量提升
  - 简言之：变量和函数的声明会提前到当前作用域的最上面。
  - 声明函数的函数体会提前，但是函数表达式的函数体并不会提前。
  - 函数比变量优先提升

## typeof 和 instanceof 的区别？实现一个 instanceof ？

- `typeof`对于原始类型来说，除了`null`都可以显示正确的类型。`typeof`对于对象来说，除了函数都后悔显示`object`，所以他并不能准确判断变量是什么类型的。
- `instanceof`内部是通过原型链来判断的，能`较为准确`判断一个对象的正确类型，之所以说是较为准确，是因为提供了方法可以去更改`instanceof`的行为。而且对于原始类型，不能通过`instanceof`判断。
- 实现自己的`instanceof`
  - todo

## call、apply及bind函数内部实现是怎么样的？

## 说一下你对JavaScript执行上下文栈和作用域的理解？

## 为什么会出现setTimeout倒计时误差？

- todo 题目待完善。